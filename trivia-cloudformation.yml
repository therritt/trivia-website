AWSTemplateFormatVersion: '2010-09-09'
Description: Trivia game backend websocket api with respective integrations

Resources:
  # VPC
  CacheVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 11.0.0.0/16
      Tags:
        - Key: Name
          Value: CacheVPC

  # Lambda (Public) Subnet
  LambdaSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref CacheVPC
      CidrBlock: 11.0.1.0/24
      AvailabilityZone: !Select [0, !GetAZs '']
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: LambdaSubnet

  # Cache (Private) Subnet
  CacheSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref CacheVPC
      CidrBlock: 11.0.2.0/24
      AvailabilityZone: !Select [0, !GetAZs '']
      Tags:
        - Key: Name
          Value: CacheSubnet

  # Internet Gateway
  CacheVpcInternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: CacheVpcInternetGateway

  # Internet Gateway Attachment
  CacheVPCGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref CacheVPC
      InternetGatewayId: !Ref CacheVpcInternetGateway

  # Route Table for Lambda (Public) Subnet
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref CacheVPC

  # Route to Internet Gateway
  InternetRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref CacheVpcInternetGateway

  # Lambda Subnet -> Route Table Association
  LambdaSubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref LambdaSubnet
      RouteTableId: !Ref PublicRouteTable

  # Security Group for lambdas to interact w/ redis cluster
  LambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Lambda function in public subnet
      VpcId: !Ref CacheVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 0
          ToPort: 65535
          CidrIp: 0.0.0.0/0

  # Security Group for Redis Cache, allows access from lambdas
  RedisAccessSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Allow access to ElastiCache from Lambda subnet
      VpcId: !Ref CacheVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 6379
          ToPort: 6379
          SourceSecurityGroupId: !Ref LambdaSecurityGroup

  # ElastiCache Redis Cluster (one node)
  RedisCluster:
    Type: AWS::ElastiCache::CacheCluster
    Properties:
      CacheNodeType: cache.t4g.micro
      Engine: redis
      NumCacheNodes: 1
      CacheSubnetGroupName: !Ref RedisSubnetGroup
      VpcSecurityGroupIds:
        - !Ref RedisAccessSecurityGroup

  # Cache Subnet Group
  RedisSubnetGroup:
    Type: AWS::ElastiCache::SubnetGroup
    Properties:
      CacheSubnetGroupName: RedisSubnetGroup
      SubnetIds:
        - !Ref CacheSubnet
      Description: Subnet group for ElastiCache Redis

  # Lambda Functions
  TriviaConnect:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: index.handler
      FunctionName: 'TriviaConnect'
      Role: !Sub 'arn:aws:iam::${AWS::AccountId}:role/LabRole'
      Code:
        ZipFile: |
          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              body: JSON.stringify('Websocket connected.'),
            };
            return response;
          };
      Runtime: nodejs20.x
      Timeout: 3
      MemorySize: 128

  TriviaJoinRoom:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: index.handler
      FunctionName: 'TriviaJoinRoom'
      Role: !Sub 'arn:aws:iam::${AWS::AccountId}:role/LabRole'
      Code:
        ZipFile: |
          const redis = require('/opt/node_modules/redis');

          // Create a Redis client
          const client = redis.createClient({
            host: process.env.REDIS_ENDPOINT,
            port: process.env.REDIS_PORT
          });

          // Lambda handler function
          exports.handler = async (event) => {
            const { userId, roomId } = JSON.parse(event.body);

            // Check if room exists
            client.exists(`room:${roomId}`, (err, exists) => {
              if (err) {
                console.error('Error checking room existence:', err);
                return {
                  statusCode: 500,
                  body: JSON.stringify({ message: 'Error checking room existence' })
                };
              }

              if (exists === 1) {
                // Room exists, proceed to add user
                const userData = { correctAnswers: 0 };
                const roomKey = `room:${roomId}`;
                const userKey = `user:${userId}`;

                // Use a multi/exec transaction for atomicity
                client.multi()
                  .hset(roomKey, userId, JSON.stringify(userData))
                  .hset('userRooms', userId, roomId)
                  .expire(roomKey, 1800)
                  .expire(userKey, 1800)
                  .exec((err, replies) => {
                    if (err) {
                      console.error('Error adding user to room:', err);
                      return {
                        statusCode: 500,
                        body: JSON.stringify({ message: 'Failed to add user to room' })
                      };
                    } else {
                      console.log(`User ${userId} added to room ${roomId}`);
                      return {
                        statusCode: 200,
                        body: JSON.stringify({ message: 'User added to room successfully' })
                      };
                    }
                  });
              } else {
                // Room does not exist
                console.log(`Room ${roomId} does not exist`);
                return {
                  statusCode: 404,
                  body: JSON.stringify({ message: `Room ${roomId} does not exist` })
                };
              }
            });
          };
      Runtime: nodejs20.x
      Timeout: 3
      MemorySize: 128
      Environment:
        Variables:
          REDIS_ENDPOINT: !Sub "${RedisCluster.RedisEndpoint.Address}"
          REDIS_PORT: !Sub "${RedisCluster.RedisEndpoint.Port}"
      VpcConfig:
        SubnetIds:
          - !Ref LambdaSubnet
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup

  TriviaCreateRoom:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: index.handler
      FunctionName: 'TriviaCreateRoom'
      Role: !Sub 'arn:aws:iam::${AWS::AccountId}:role/LabRole'
      Code:
        ZipFile: |
          const redis = require('/opt/node_modules/redis');
          const crypto = require('crypto');

          // Create a Redis client
          const client = redis.createClient({
            host: process.env.REDIS_ENDPOINT,
            port: process.env.REDIS_PORT
          });

          // Lambda handler function
          exports.handler = async (event) => {
            try {
              const roomCode = crypto.randomBytes(4).toString('hex').toUpperCase();

              // Check if the room code already exists in Redis
              client.exists(`room:${roomCode}`, async (err, exists) => {
                if (err) {
                  console.error('Error checking room existence:', err);
                  return {
                    statusCode: 500,
                    body: JSON.stringify({ message: 'Error checking room existence' })
                  };
                }

                if (exists === 1) {
                  // Room code already exists, generate a new one
                  return {
                    statusCode: 500,
                    body: JSON.stringify({ message: 'Room code already exists' })
                  };
                } else {
                  // Room code is unique, proceed to create the room
                  const userId = JSON.parse(event.body).userId;
                  const userData = { correctAnswers: 0, host: true };
                  const roomKey = `room:${roomCode}`;
                  const userKey = `user:${userId}`;

                  // Use a multi/exec transaction for atomicity
                  client.multi()
                    .hset(roomKey, userId, JSON.stringify(userData))
                    .hset('userRooms', userId, roomCode)
                    .expire(roomKey, 1800)
                    .expire(userKey, 1800)
                    .exec((err, replies) => {
                      if (err) {
                        console.error('Error creating room:', err);
                        return {
                          statusCode: 500,
                          body: JSON.stringify({ message: 'Failed to create room' })
                        };
                      } else {
                        console.log(`Room ${roomCode} created with host ${userId}`);
                        return {
                          statusCode: 200,
                          body: JSON.stringify({ message: `Room ${roomCode} created successfully` })
                        };
                      }
                    });
                }
              });
            } catch (error) {
              console.error('Error generating room code:', error);
              return {
                statusCode: 500,
                body: JSON.stringify({ message: 'Error generating room code' })
              };
            }
          };
      Runtime: nodejs20.x
      Timeout: 3
      MemorySize: 128
      Environment:
        Variables:
          REDIS_ENDPOINT: !Sub "${RedisCluster.RedisEndpoint.Address}"
          REDIS_PORT: !Sub "${RedisCluster.RedisEndpoint.Port}"
      VpcConfig:
        SubnetIds:
          - !Ref LambdaSubnet
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup

  TriviaDisconnect:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: index.handler
      FunctionName: 'TriviaDisconnect'
      Role: !Sub 'arn:aws:iam::${AWS::AccountId}:role/LabRole'
      Code:
        ZipFile: |
          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              body: JSON.stringify('Hello from Lambda!'),
            };
            return response;
          };
      Runtime: nodejs20.x
      Timeout: 3
      MemorySize: 128
      Environment:
        Variables:
          REDIS_ENDPOINT: !Sub "${RedisCluster.RedisEndpoint.Address}"
          REDIS_PORT: !Sub "${RedisCluster.RedisEndpoint.Port}"
      VpcConfig:
        SubnetIds:
          - !Ref LambdaSubnet
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup

  TriviaStartGame:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: index.handler
      FunctionName: 'TriviaStartGame'
      Role: !Sub 'arn:aws:iam::${AWS::AccountId}:role/LabRole'
      Code:
        ZipFile: |
          const { ApiGatewayManagementApiClient, PostToConnectionCommand} = require("@aws-sdk/client-apigatewaymanagementapi");
          const client = new ApiGatewayManagementApiClient({ endpoint: process.env.CONNECTION_URL });
            
          exports.handler = async (event) => {
            const connectionId = event.requestContext.connectionId;
            const message = new PostToConnectionCommand({ ConnectionId: connectionId, Data: "Game started" });
            await client.send(message);

            const response = { statusCode: 200 };
            return response;
          };
      Runtime: nodejs20.x
      Timeout: 3
      MemorySize: 128
      Environment:
        Variables:
          CONNECTION_URL: !Sub 'https://${TriviaWebsocketApi}.execute-api.${AWS::Region}.amazonaws.com/production'

  TriviaSubmitAnswer:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: index.handler
      FunctionName: 'TriviaSubmitAnswer'
      Role: !Sub 'arn:aws:iam::${AWS::AccountId}:role/LabRole'
      Code:
        ZipFile: |
          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              body: JSON.stringify('Hello from Lambda!'),
            };
            return response;
          };
      Runtime: nodejs20.x
      Timeout: 3
      MemorySize: 128

  # Lambda Invocation Permissions
  ConnectPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - TriviaWebsocketApi
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref TriviaConnect
      Principal: apigateway.amazonaws.com

  DisconnectPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - TriviaWebsocketApi
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref TriviaDisconnect
      Principal: apigateway.amazonaws.com

  StartGamePermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - TriviaWebsocketApi
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref TriviaStartGame
      Principal: apigateway.amazonaws.com

  SubmitAnswerPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - TriviaWebsocketApi
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref TriviaSubmitAnswer
      Principal: apigateway.amazonaws.com

  # Trivia WebSocket API
  TriviaWebsocketApi:
    Type: 'AWS::ApiGatewayV2::Api'
    Properties:
      Name: TriviaWebsocketApi
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: '$request.body.action'

  # Deployment
  Deployment:
    Type: AWS::ApiGatewayV2::Deployment
    DependsOn:
      - ConnectRoute
      - DisconnectRoute
      - StartGameRoute
      - SubmitAnswerRoute
    Properties:
      ApiId: !Ref TriviaWebsocketApi

  # Stages
  ApiStage:
    Type: 'AWS::ApiGatewayV2::Stage'
    Properties:
      ApiId: !Ref TriviaWebsocketApi
      StageName: production
      DeploymentId: !Ref Deployment

  # WebSocket Routes
  ConnectRoute:
    Type: 'AWS::ApiGatewayV2::Route'
    Properties:
      ApiId: !Ref TriviaWebsocketApi
      RouteKey: '$connect'
      AuthorizationType: NONE
      Target: !Join
        - '/'
        -
          - 'integrations'
          - !Ref ConnectIntegration

  DisconnectRoute:
    Type: 'AWS::ApiGatewayV2::Route'
    Properties:
      ApiId: !Ref TriviaWebsocketApi
      RouteKey: '$disconnect'
      AuthorizationType: NONE
      Target: !Join
        - '/'
        -
          - 'integrations'
          - !Ref DisconnectIntegration

  StartGameRoute:
    Type: 'AWS::ApiGatewayV2::Route'
    Properties:
      ApiId: !Ref TriviaWebsocketApi
      RouteKey: 'startGame'
      AuthorizationType: NONE
      Target: !Join
        - '/'
        -
          - 'integrations'
          - !Ref StartGameIntegration

  SubmitAnswerRoute:
    Type: 'AWS::ApiGatewayV2::Route'
    Properties:
      ApiId: !Ref TriviaWebsocketApi
      RouteKey: 'submitAnswer'
      AuthorizationType: NONE
      Target: !Join
        - '/'
        - 
          - 'integrations'
          - !Ref SubmitAnswerIntegration

  # Integrations
  ConnectIntegration:
    Type: 'AWS::ApiGatewayV2::Integration'
    Properties:
      ApiId: !Ref TriviaWebsocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TriviaConnect.Arn}/invocations'

  DisconnectIntegration:
    Type: 'AWS::ApiGatewayV2::Integration'
    Properties:
      ApiId: !Ref TriviaWebsocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TriviaDisconnect.Arn}/invocations'

  StartGameIntegration:
    Type: 'AWS::ApiGatewayV2::Integration'
    Properties:
      ApiId: !Ref TriviaWebsocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TriviaStartGame.Arn}/invocations'

  SubmitAnswerIntegration:
    Type: 'AWS::ApiGatewayV2::Integration'
    Properties:
      ApiId: !Ref TriviaWebsocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TriviaSubmitAnswer.Arn}/invocations'
